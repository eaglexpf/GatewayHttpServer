<?php
/**
 * User: Roc.xu
 * Date: 2017/5/17
 * Time: 15:19
 */

namespace GatewayHttpServer;

use GatewayHttpServer\lib\connection\GatewayConnection;
use GatewayHttpServer\Protocols\GatewayHttpProtocol;
use Workerman\Connection\AsyncTcpConnection;
use Workerman\Lib\Timer;
use Workerman\Worker;

class Business extends Worker{
    /**
     * 注册中心地址
     * @var string
     */
    public $register_address = '127.0.0.1:2136';
    /**
     * 秘钥
     * @var string
     */
    public $secretKey = '';
    public $eventHandler = 'GatewayHttpServer\lib\Events';
    public $configFile = '';
    /**
     * gateway链接对象
     * @var array
     */
//    protected $gateway_connections = [];
    /**
     * 等待链接的gateway地址（连接失败的）
     * @var array
     */
    protected $_waitingGatewayAddress = [];
    /**
     * 处于连接状态的gateway地址（连接成功的）
     * @var array
     */
    protected $_connectionGatewayAddress = [];
    /**
     * 所有的gateway通讯地址
     * @var array
     */
    protected $_gatewayAddress = [];
    /**
     * 用户设置的自定义回调
     * @var null
     */
    protected $_onWorkerStart = null;
    protected $_onWorkerReload = null;
    protected $_onWorkerStop = null;
    /**
     * 到注册中心的链接
     * @var null
     */
    protected $registerConnection = null;
    /**
     * 用户保持内部长连接的心跳时间间隔
     */
    const CONNECTION_PING_INTERVAL = 25;

    /**
     * Business constructor.
     * @param string $socket_name
     * @param array $context_option
     */
    public function __construct($socket_name = '', $context_option = []){
        parent::__construct($socket_name, $context_option);
    }

    public function run(){
        $this->_onWorkerStart = $this->onWorkerStart;
        $this->onWorkerStart = [$this,'onWorkerStart'];
        $this->_onWorkerReload = $this->onWorkerReload;
        $this->onWorkerReload = [$this,'onWorkerReload'];
        $this->_onWorkerStop = $this->onWorkerStop;
        parent::run(); // TODO: Change the autogenerated stub
    }

    /**
     * 进程启动时
     */
    protected function onWorkerStart(){
        //设置协议别名
        if (!class_exists('\Protocols\GatewayHttpProtocol')) {
            class_alias('GatewayHttpServer\Protocols\GatewayHttpProtocol', 'Protocols\GatewayHttpProtocol');
        }
        //发起与注册中心的连接
        $this->connectToRegister();
        // 如果Register服务器不在本地服务器，则需要保持心跳
        if (strpos($this->register_address, '127.0.0.1') !== 0) {
            Timer::add(self::CONNECTION_PING_INTERVAL, [$this, 'pingRegister']);
        }
        GatewayConnection::$configFile = $this->configFile;
        if (is_callable($this->eventHandler . '::onWorkerStart')) {
            call_user_func($this->eventHandler . '::onWorkerStart', $this);
        }
    }
    protected function onWorkerReload(){
    }

    /**
     * 尝试链接gateway
     * @param $addr
     */
    public function tryConnectGateway($addr){
        //设置协议别名
        if (!class_exists('\Protocols\GatewayHttpProtocol')) {
            class_alias('GatewayHttpServer\Protocols\GatewayHttpProtocol', 'Protocols\GatewayHttpProtocol');
        }
        //地址在已连接的gateway缓存连接中不存在；且存在于全部的地址缓存中
        if (!isset($this->_connectionGatewayAddress[$addr])&&isset($this->_gatewayAddress[$addr])){
            $gateway_connection = new AsyncTcpConnection("GatewayHttpProtocol://$addr");
            //给连接设置gateway来源地址
            $gateway_connection->gateway_address = $addr;
            //gateway连接的回调函数
            $gateway_connection->onConnect = [$this,'onGatewayConnect'];
            $gateway_connection->onMessage = [$this,'onGatewayMessage'];
            $gateway_connection->onClose = [$this,'onGatewayClose'];
            $gateway_connection->onError = [$this,'onGatewayError'];

            //格式化数据；发送给gateway验证
            $gateway_data = GatewayHttpProtocol::$empty;
            $gateway_data['cmd'] = GatewayHttpProtocol::CMD_BUSINESS_TO_GATEWAY;
            $gateway_data['body'] = json_encode([
                'business_key' =>"{$this->name}:{$this->id}",
                'secret_key' => $this->secretKey
            ]);
            $gateway_connection->send($gateway_data);

            $gateway_connection->connect();
        }
        //将地址从失败的缓存中删除
        unset($this->_waitingGatewayAddress[$addr]);
    }

    /**
     * 与gateway建立连接时
     * @param $connection
     */
    public function onGatewayConnect($connection){
        //检查链接的gateway来源地址是否存在已连接的gateway链接；存在的话关闭该链接
        if (isset($this->_connectionGatewayAddress[$connection->gateway_address])){
            $connection->close();
            return ;
        }
        //将该地址和连接加入已连接的gateway链接缓存中
        $this->gateway_connections[$connection->gateway_address] = $connection;
        //删除在连接失败缓存中的改地址
        unset($this->_waitingGatewayAddress[$connection->gateway_address]);
    }

    /**
     * 当gateway发来数据时
     * @param $connection
     * @param $data
     */
    public function onGatewayMessage($connection,$data){
        //gateway发来的信息必须是格式化的（必须有cmd）
        if (empty($data['cmd'])){
            echo "gateway msg not right msg\n";
            $connection->close();
            return ;
        }
        $cmd = $data['cmd'];
        //来源数据
        GatewayConnection::setConstruct($data);
        GatewayConnection::setGatewayConnection($connection);
        switch ($cmd){
            case GatewayHttpProtocol::CMD_GATEWAY_ON_CONNECT:
                //客户端对gateway发起连接的回调
                if (is_callable($this->eventHandler . '::onConnect')) {
                    call_user_func($this->eventHandler . '::onConnect', $data['connection_id']);
                }
                break;
            case GatewayHttpProtocol::CMD_GATEWAY_ON_MESSAGE:
                //客户端对gateway发送信息的回调
                if (is_callable($this->eventHandler . '::onMessage')) {
                    call_user_func($this->eventHandler . '::onMessage', $data['connection_id'],$data['body']);
                }
                break;
            case GatewayHttpProtocol::CMD_GATEWAY_ON_CLOSE:
                //客户端关闭对gateway链接的回调
                if (is_callable($this->eventHandler . '::onClose')) {
                    call_user_func($this->eventHandler . '::onClose', $data['connection_id']);
                }
                break;
            case 'ping':
                break;
            default:
        }
    }

    /**
     * 当gateway断开连接时
     * @param $connection
     */
    public function onGatewayClose($connection){
        $addr = $connection->gateway_address;//获取连接的gateway来源地址
        unset($this->gateway_connections[$addr]);//将改地址从gateway连接缓存中删除
        //如果该地址存在于地址缓存中；并且不在失败的gateway链接缓存中
        if (isset($this->_gatewayAddress[$addr])&&!isset($this->_waitingGatewayAddress[$addr])){
            Timer::add(1,[$this,'tryConnectGateway'],[$addr],false);//定时连接
            $this->_waitingGatewayAddress[$addr] = $addr;//将改地址加入失败的gateway连接缓存中
        }
    }

    /**
     * 与gateway的链接发生错误
     * @param $connection
     * @param $err_no
     * @param $err_msg
     */
    public function onGatewayError($connection,$err_no,$err_msg){
        echo "GatewayConnection Error : $err_no ,$err_msg\n";
    }

    /**
     * 检测gateway地址是否全部链接；如果有未连接的端口，则尝试链接
     * @param $address_list
     */
    protected function checkGatewayConnections($address_list){
        if (empty($address_list)){
            return;
        }
        foreach ($address_list as $addr){
            //如果地址在已连接的缓存中存在；则忽略
            if (isset($this->_connectionGatewayAddress[$addr])){
                continue;
            }
            //如果地址在连接失败的地址中不存在（这一步同时也意味着该地址在已连接的缓存中也不存在）
            //尝试对该地址发起连接
            if (!isset($this->_waitingGatewayAddress[$addr])){
                $this->tryConnectGateway($addr);
            }
        }
    }

    /***********************
     *
     * 与注册中心的交互
     *
     **********************/

    /**
     * 连接到注册中心
     */
    public function connectToRegister(){
        $this->registerConnection = new AsyncTcpConnection("text://{$this->register_address}");
        $this->registerConnection->send('{"event":"business_connect","secret_key":"' . $this->secretKey . '"}');
        $this->registerConnection->onClose = [$this,'onRegisterClose'];
        $this->registerConnection->onMessage = [$this,'onRegisterMessage'];
        $this->registerConnection->connect();
    }

    /**
     * 向register发送心跳，保持长连接
     */
    protected function pingRegister(){
        if ($this->registerConnection){
            $this->registerConnection->send('{"event":"ping"}');
        }
    }

    /**
     * 注册中心发来数据时
     * @param $register_connection
     * @param $data
     */
    public function onRegisterMessage($register_connection,$data){
        $data = @json_decode($data,true);
        if (!isset($data['event'])) {
            echo "Received bad data from Register\n";
            return;
        }
        $event = $data['event'];
        switch ($event){
            case 'gateway_address':
                if (!is_array($data['address'])){
                    echo "Received bad data from Register. Addresses empty\n";
                    return;
                }
                $address = $data['address'];
                foreach ($address as $addr){
                    //检测注册中心发来的gateway地址是否有不在本地缓存中的gateway地址；没有的话将其加入本地缓存
                    if (!isset($this->_gatewayAddress[$addr])){
                        $this->_gatewayAddress[$addr] = $addr;
                    }
                }
                //检查注册中心发来的gateway数组地址中是否有未发起连接的gateway地址
                $this->checkGatewayConnections($address);
                break;
            default:
                echo "Receive bad event:$event from Register.\n";
        }
    }

    /**
     * 与注册中心的链接关闭时，定时重连
     */
    public function onRegisterClose(){
        Timer::add(1,[$this,'connectToRegister'],null,false);
    }

}