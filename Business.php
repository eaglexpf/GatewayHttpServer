<?php
/**
 * User: Roc.xu
 * Date: 2018/3/1
 * Time: 17:23
 */

namespace GatewayHttpServer;


use Workerman\Connection\AsyncTcpConnection;
use Workerman\Connection\TcpConnection;
use Workerman\Lib\Timer;
use Workerman\Worker;

class Business extends Worker
{
    //服务名称
    public $name = 'business';
    //秘钥
    public $secretKey = '';
    //注册中心地址
    public $register_address = '';
    //事件处理类
    public $eventHandler = 'GatewayHttpServer\lib\Events';
    //发送缓冲区最大值
    public $maxBufferSize = 50*1024*1024;
    //心跳
    public $ping_time = 0;
    //配置文件地址
    public $config_dir = '';
    
    //注册中心链接
    protected $connections_register = null;
    //gateway链接集合
    protected $connections_gateway = [];
    //等待连接gateway的地址集合
    protected $connections_wait_address = [];
    //gateway_address集合
    protected $gateway_address = [];
    //事件属性集合
    public $event_code = [];
    
    public function run()
    {
        $this->onWorkerStart = [$this,'onWorkerStart'];
        $this->onWorkerStop = [$this,'onWorkerStop'];
        parent::run(); // TODO: Change the autogenerated stub
    }

    public function onWorkerStart($worker){
        //默认设置
        TcpConnection::$defaultMaxSendBufferSize = $this->maxBufferSize;
        TcpConnection::$maxPackageSize = $this->maxBufferSize;
        $worker->event_code = require_once __DIR__.'/config/event_code.php';
        $worker->config_dir = $this->config_dir;
        $this->id = strtoupper(md5(uniqid(mt_rand(), true)));

        //注册服务
        $this->registerAddress();
        if (is_callable($this->eventHandler.'::onWorkerStart')){
            call_user_func($this->eventHandler.'::onWorkerStart',$worker);
        }
    }
    public function onWorkerStop($worker){
        if (is_callable($this->eventHandler.'::onWorkerStop')){
            call_user_func($this->eventHandler.'::onWorkerStop',$worker);
        }
    }
    //注册服务
    public function registerAddress(){
        $this->connections_register = new AsyncTcpConnection("Text://{$this->register_address}");
        $this->connections_register->onConnect = [$this,'onRegisterConnect'];
        $this->connections_register->onMessage = [$this,'onRegisterMessage'];
        $this->connections_register->onClose = [$this,'onRegisterClose'];
        $this->connections_register->connect();
    }
    //与注册中心建立连接回调
    public function onRegisterConnect($connection){
        $connection->id = strtoupper(md5(uniqid(mt_rand(), true)));
        $data = json_encode([
            'event' => $this->event_code['businessConnectToRegister'],
            'secret_key' => $this->secretKey,
            'business_id' => $this->id
        ],320);
        $connection->send($data);
        $this->pingRegister();
    }
    //注册中心发送的消息
    public function onRegisterMessage($connection,$buffer){
        $data = @json_decode($buffer,true);
        if (!isset($data['event'])){
            echo "business:error,register msg must have event";
            return;
        }
        switch ($data['event']){
            case $this->event_code['registerBroadcastGatewayAddress']://gateway地址广播
                if (!is_array($data['address'])){
                    echo "business:error,register msg must is array";
                    return;
                }
                $this->checkGatewayConnections($data['address']);
                break;
            default:
                echo "business:error,event:{$data['event']} from Register.";
        }
    }
    //注册中心连接关闭
    public function onRegisterClose($connection){
        Timer::add(1,[$this,'registerAddress'],null,false);
        if (isset($this->connections_register->ping_time_id)){
            Timer::del($this->connections_register->ping_time_id);
        }
    }
    //与注册服务中心的心跳
    public function pingRegister(){
        if ($this->connections_register){
            if (strpos($this->register_address,'127.0.0.1')===false){
                if (!$this->ping_time){
                    return false;
                }
                $data = json_encode([
                    'event' => $this->event_code['ping']
                ],320);
                $this->connections_register->ping_timer_id =  Timer::add($this->ping_time,function ()use($data){
                    $this->connections_register->send($data);
                });
            }
        }
    }

    //检查地址列表
    public function checkGatewayConnections($address_list){
        //连接中的地址集合
        $connection_address = [];
        foreach ($this->connections_gateway as $kk=>$vv){
            array_push($connection_address,$vv->gateway_address);
        }
        //等待连接中的地址集合
        $wait_address = [];
        foreach ($this->connections_wait_address as $kk=>$vv){
            array_push($wait_address,$kk);
        }
        //本地缓存中的所有地址集合
        $address_data = array_merge($connection_address,$wait_address);
        //新的地址列表中如果有某个地址不在本地的地址列表中，则将该地址加入等待连接的地址集合中
        foreach ($address_list as $k=>$v){
            if (!in_array($v,$address_data)){
                $this->connections_wait_address[$v] = ['time_id'=>null,'time_num'=>0];
            }
        }
        //连接中的地址不在地址列表中；关闭该链接
        foreach ($this->connections_gateway as $k=>$v){
            if (!in_array($v->gateway_address,$address_list)){
                $v->close();
            }
        }
        //等待连接集合中的地址不在地址列表中；删除等待连接中的地址
        foreach ($this->connections_wait_address as $k=>$v){
            if (!in_array($k,$address_list)){
                //删除定时器
                if ($this->connections_wait_address[$k]['time_id']){
                    Timer::del($this->connections_wait_address[$k]['time_id']);
                }
                unset($this->connections_wait_address[$k]);
            }elseif (!$this->connections_wait_address[$k]['time_id']){
                $this->connections_wait_address[$k]['time_id'] = Timer::add(1,function ()use($k){
                    $this->tryConnectToGateway($k);
                });
            }
        }
    }

    //尝试链接gateway服务
    public function tryConnectToGateway($address){
        if (empty($address)){
            return false;
        }
        foreach ($this->connections_gateway as $k=>$v){
            if (isset($v->gatewau_address)&&$v->gatewau_address==$address){
                return false;
            }
        }
        //为通讯协议类设置别名；可以让workerman使用
        if (!class_exists('\Protocols\BusinessProtocol')){
            class_alias('GatewayHttpServer\Protocols\BusinessProtocol','Protocols\BusinessProtocol');
        }
        $gateway_con = new AsyncTcpConnection("BusinessProtocol://{$address}");
        $data = [
            'event' => $this->event_code['businessConnectToGateway'],
            'secret_key' => $this->secretKey,
            'business_id' => $this->id
        ];
        $gateway_con->onConnect = function ($connection)use($data,$address){
            $connection->id = strtoupper(md5(uniqid(mt_rand(), true)));
            $connection->send($data);
            $connection->gateway_address = $address;
            $this->connections_gateway[$connection->id] = $connection;
            //判断等待连接集合中是否有该地址
            if (isset($this->connections_wait_address[$address])){
                if ($this->connections_wait_address[$address]['time_id']){
                    Timer::del($this->connections_wait_address[$address]['time_id']);
                }
                unset($this->connections_wait_address[$address]);
            }
            $this->pingGateway($connection);
        };
        $gateway_con->onMessage = [$this,'onGatewayMessage'];
        $gateway_con->onClose = [$this,'onGatewayClose'];
        $gateway_con->connect();
    }
    public function onGatewayMessage($connection,$data){
        if (!isset($data['event'])){
            echo 'business:error,gateway msg must have event';
            return false;
        }
        switch ($data['event']){
            case $this->event_code['clientConnect']:
                if (is_callable($this->eventHandler.'::onConnect')){
                    call_user_func($this->eventHandler.'::onConnect',$data['client_id']);
                }
                break;
            case $this->event_code['clientMessage']:
                if (is_callable($this->eventHandler.'::onMessage')){
                    call_user_func($this->eventHandler.'::onMessage',$connection,$data);
                }
                break;
            case $this->event_code['clientClose']:
                if (is_callable($this->eventHandler.'::onClose')){
                    call_user_func($this->eventHandler.'::onClose',$data['client_id']);
                }
                break;
            default:
                echo 'business:error,gateway msg event must register';
        }

    }
    public function onGatewayClose($connection){
        //删除链接集合中的位置
        if (isset($this->connections_gateway[$connection->id])){
            unset($this->connections_gateway[$connection->id]);
        }
        //删除心跳
        if (isset($connection->ping_time_id)){
            Timer::del($connection->ping_time_id);
        }
        $gateway_address = isset($connection->gateway_address)?$connection->gateway_address:'';
        if (empty($gateway_address)){
            return false;
        }
        //将该链接放于等待连接的集合
        if (!isset($this->connections_wait_address[$gateway_address])){
            $this->connections_wait_address[$gateway_address] = ['time_id'=>null,'time_num'=>0];
        }elseif($this->connections_wait_address[$gateway_address]['time_num']<3600){
            $this->connections_wait_address[$gateway_address]['time_num'] += 1;
        }else{
            //重试建立连接超过失效，删除改地址
            if ($this->connections_wait_address[$gateway_address]['time_id']){
                Timer::del($this->connections_wait_address[$gateway_address]['time_id']);
            }
            unset($this->connections_wait_address[$gateway_address]);
        }
    }
    //与gateway的心跳
    public function pingGateway($connection){
        $gateway_address = isset($connection->gateway_address)?$connection->gateway_address:'';
        if (strpos($gateway_address,'127.0.0.1')===false){
            if (!$this->ping_time){
                return false;
            }
            $data = [
                'event' => $this->event_code['ping'],
                'msg' => 'this is ping'
            ];
            $connection->ping_time_id =  Timer::add($this->ping_time,function ()use($connection,$data){
                $connection->send($data);
            });
        }
    }
}